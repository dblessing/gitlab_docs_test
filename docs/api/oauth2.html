<h1 id="gitlab-as-an-oauth2-client">GitLab as an OAuth2 client</h1>

<p>This document is about using other OAuth authentication service providers to sign into GitLab.
If you want GitLab to be an OAuth authentication service provider to sign into other services please see the <a href="../integration/oauth_provider.md">Oauth2 provider documentation</a>.</p>

<p>OAuth2 is a protocol that enables us to authenticate a user without requiring them to give their password. </p>

<p>Before using the OAuth2 you should create an application in user&rsquo;s account. Each application gets a unique App ID and App Secret parameters. You should not share these.</p>

<p>This functionality is based on <a href="https://github.com/doorkeeper-gem/doorkeeper">doorkeeper gem</a></p>

<h2 id="web-application-flow">Web Application Flow</h2>

<p>This flow is using for authentication from third-party web sites and is probably used the most. 
It basically consists of an exchange of an authorization token for an access token. For more detailed info, check out the <a href="http://tools.ietf.org/html/rfc6749#section-4.1">RFC spec here</a></p>

<p>This flow consists from 3 steps.</p>

<h3 id="1-registering-the-client">1. Registering the client</h3>

<p>Create an application in user&rsquo;s account profile.</p>

<h3 id="2-requesting-authorization">2. Requesting authorization</h3>

<p>To request the authorization token, you should visit the <code class="prettyprint">/oauth/authorize</code> endpoint. You can do that by visiting manually the URL:</p>
<pre class="highlight plaintext"><code>http://localhost:3000/oauth/authorize?client_id=APP_ID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code
</code></pre>

<p>Where REDIRECT_URI is the URL in your app where users will be sent after authorization.     </p>

<h3 id="3-requesting-the-access-token">3. Requesting the access token</h3>

<p>To request the access token, you should use the returned code and exchange it for an access token. To do that you can use any HTTP client. In this case, I used rest-client:</p>
<pre class="highlight plaintext"><code>parameters = 'client_id=APP_ID&amp;client_secret=APP_SECRET&amp;code=RETURNED_CODE&amp;grant_type=AUTHORIZATION_CODE&amp;redirect_uri=REDIRECT_URI'
RestClient.post 'http://localhost:3000/oauth/token', parameters

# The response will be
{
 "access_token": "de6780bc506a0446309bd9362820ba8aed28aa506c71eedbe1c5c4f9dd350e54",
 "token_type": "bearer", 
 "expires_in": 7200,
 "refresh_token": "8257e65c97202ed1726cf9571600918f3bffb2544b26e00a61df9897668c33a1"
}
</code></pre>

<p>You can now make requests to the API with the access token returned.</p>

<h3 id="use-the-access-token-to-access-the-api">Use the access token to access the API</h3>

<p>The access token allows you to make requests to the API on a behalf of a user.</p>
<pre class="highlight plaintext"><code>GET https://localhost:3000/api/v3/user?access_token=OAUTH-TOKEN
</code></pre>

<p>Or you can put the token to the Authorization header:</p>
<pre class="highlight plaintext"><code>curl -H "Authorization: Bearer OAUTH-TOKEN" https://localhost:3000/api/v3/user
</code></pre>

<h2 id="resource-owner-password-credentials">Resource Owner Password Credentials</h2>

<p>In this flow, a token is requested in exchange for the resource owner credentials (username and password). 
The credentials should only be used when there is a high degree of trust between the resource owner and the client (e.g. the
client is part of the device operating system or a highly privileged application), and when other authorization grant types are not
available (such as an authorization code).</p>

<p>Even though this grant type requires direct client access to the resource owner credentials, the resource owner credentials are used
for a single request and are exchanged for an access token.  This grant type can eliminate the need for the client to store the
resource owner credentials for future use, by exchanging the credentials with a long-lived access token or refresh token.
You can do POST request to <code class="prettyprint">/oauth/token</code> with parameters:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"grant_type"</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s2">"password"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"username"</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s2">"user@example.com"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"password"</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s2">"sekret"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>Then, you&rsquo;ll receive the access token back in the response:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"access_token"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1f0af717251950dbd4d73154fdf0a474a5c5119adad999683f5b450c460726aa"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"token_type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bearer"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"expires_in"</span><span class="p">:</span><span class="w"> </span><span class="mi">7200</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>For testing you can use the oauth2 ruby gem:</p>
<pre class="highlight plaintext"><code>client = OAuth2::Client.new('the_client_id', 'the_client_secret', :site =&gt; "http://example.com")
access_token = client.password.get_token('user@example.com', 'sekret')
puts access_token.token
</code></pre>
