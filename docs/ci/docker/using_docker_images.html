<h1 id="using-docker-images">Using Docker Images</h1>

<p>GitLab CI can use <a href="https://www.docker.com/">Docker Engine</a> to build projects. </p>

<p>Docker is an open-source project that allows to use predefined images to run applications 
in independent &ldquo;containers&rdquo; that are run within a single Linux instance. 
<a href="https://registry.hub.docker.com/">Docker Hub</a> have rich database of  built images that can be used to build applications.</p>

<p>Docker when used with GitLab CI runs each build in separate and isolated container using predefined image and always from scratch.
It makes it easier to have simple and reproducible build environment that can also be run on your workstation.
This allows you to test all commands from your shell, rather than having to test them on a CI server.</p>

<h3 id="register-docker-runner">Register Docker runner</h3>

<p>To use GitLab Runner with Docker you need to register new runner to use <code class="prettyprint">docker</code> executor:</p>
<pre class="highlight shell"><code>gitlab-ci-multi-runner register <span class="se">\</span>
  --url <span class="s2">"https://gitlab.com/"</span> <span class="se">\</span>
  --registration-token <span class="s2">"PROJECT_REGISTRATION_TOKEN"</span> <span class="se">\</span>
  --description <span class="s2">"docker-ruby-2.1"</span> <span class="se">\</span>
  --executor <span class="s2">"docker"</span> <span class="se">\</span>
  --docker-image ruby:2.1 <span class="se">\</span>
  --docker-postgres latest <span class="se">\</span>
  --docker-mysql latest
</code></pre>

<p><strong>The registered runner will use <code class="prettyprint">ruby:2.1</code> image and will run two services (<code class="prettyprint">postgres:latest</code> and <code class="prettyprint">mysql:latest</code>) that will be accessible for time of the build.</strong></p>

<h3 id="what-is-image">What is image?</h3>

<p>The image is the name of any repository that is present in local Docker Engine or any repository that can be found at <a href="https://registry.hub.docker.com/">Docker Hub</a>. 
For more information about the image and Docker Hub please read the <a href="https://docs.docker.com/introduction/understanding-docker/">Docker Fundamentals</a>.</p>

<h3 id="what-is-service">What is service?</h3>

<p>Service is just another image that is run for time of your build and is linked to your build. This allows you to access the service image during build time. 
The service image can run any application, but most common use case is to run some database container, ie.: <code class="prettyprint">mysql</code>. 
It&rsquo;s easier and faster to use existing image, run it as additional container than install <code class="prettyprint">mysql</code> every time project is built.</p>

<h4 id="how-is-service-linked-to-the-build">How is service linked to the build?</h4>

<p>There&rsquo;s good document that describes how Docker linking works: <a href="https://docs.docker.com/userguide/dockerlinks/">Linking containers together</a>. 
To summarize: if you add <code class="prettyprint">mysql</code> as service to your application, the image will be used to create container that is linked to build container. 
The service container for MySQL will be accessible under hostname <code class="prettyprint">mysql</code>.
So, <strong>to access your database service you have to connect to host: <code class="prettyprint">mysql</code> instead of socket or <code class="prettyprint">localhost</code></strong>.</p>

<h3 id="how-to-use-other-images-as-services">How to use other images as services?</h3>

<p>You are not limited to have only database services. 
You can hand modify <code class="prettyprint">config.toml</code> to add any image as service found at <a href="https://registry.hub.docker.com/">Docker Hub</a>. 
Look for <code class="prettyprint">[runners.docker]</code> section:
<code class="prettyprint">
[runners.docker]
  image = &quot;ruby:2.1&quot;
  services = [&quot;mysql:latest&quot;, &quot;postgres:latest&quot;]
</code></p>

<p>For example you need <code class="prettyprint">wordpress</code> instance to test some API integration with <code class="prettyprint">Wordpress</code>. 
You can for example use this image: <a href="https://registry.hub.docker.com/u/tutum/wordpress/">tutum/wordpress</a>. 
This is image that have fully preconfigured <code class="prettyprint">wordpress</code> and have <code class="prettyprint">MySQL</code> server built-in:
<code class="prettyprint">
[runners.docker]
  image = &quot;ruby:2.1&quot;
  services = [&quot;mysql:latest&quot;, &quot;postgres:latest&quot;, &quot;tutum/wordpress:latest&quot;]
</code></p>

<p>Next time when you run your application the <code class="prettyprint">tutum/wordpress</code> will be started 
and you will have access to it from your build container under hostname: <code class="prettyprint">tutum_wordpress</code>.</p>

<p>Alias hostname for the service is made from the image name:
1. Everything after <code class="prettyprint">:</code> is stripped,
2. &rsquo;/&rsquo; is replaced to <code class="prettyprint">_</code>.</p>

<h3 id="configuring-services">Configuring services</h3>

<p>Many services accept environment variables, which allow you to easily change database names or set account names depending on the environment.</p>

<p>GitLab Runner 0.5.0 and up passes all YAML-defined variables to created service containers.</p>

<ol>
<li><p>To configure database name for <a href="https://registry.hub.docker.com/u/library/postgres/">postgres</a> service,
you need to set POSTGRES_DB.</p>
<pre class="highlight yaml"><code><span class="s">services</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">postgres</span>

<span class="s">variables</span><span class="pi">:</span>
  <span class="s">POSTGRES_DB</span><span class="pi">:</span> <span class="s">gitlab</span>
</code></pre></li>
<li><p>To use <a href="https://registry.hub.docker.com/u/library/mysql/">mysql</a> service with empty password for time of build, 
you need to set MYSQL_ALLOW_EMPTY_PASSWORD.</p>
<pre class="highlight yaml"><code><span class="s">services</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">mysql</span>

<span class="s">variables</span><span class="pi">:</span>
  <span class="s">MYSQL_ALLOW_EMPTY_PASSWORD</span><span class="pi">:</span> <span class="s">yes</span>
</code></pre></li>
</ol>

<p>For other possible configuration variables check the 
https://registry.hub.docker.com/u/library/mysql/ or https://registry.hub.docker.com/u/library/postgres/
or README page for any other Docker image.</p>

<p><strong>Note: All variables will passed to all service containers. It&rsquo;s not designed to distinguish which variable should go where.</strong></p>

<h3 id="overwrite-image-and-services">Overwrite image and services</h3>

<p>It&rsquo;s possible to overwrite <code class="prettyprint">docker-image</code> and specify services from <code class="prettyprint">.gitlab-ci.yml</code>.
If you add to your YAML the <code class="prettyprint">image</code> and the <code class="prettyprint">services</code> these parameters
be used instead of the ones that were specified during runner&rsquo;s registration.
&ldquo;`
image: ruby:2.2
services:
  - postgres:9.3
before_install:
  - bundle install</p>

<p>test:
  script:
  - bundle exec rake spec
&rdquo;`</p>

<p>It&rsquo;s possible to define image and service per-job:
&ldquo;`
before_install:
  - bundle install</p>

<p>test:2.1:
  image: ruby:2.1
  services:
  - postgres:9.3
  script:
  - bundle exec rake spec</p>

<p>test:2.2:
  image: ruby:2.2
  services:
  - postgres:9.4
  script:
  - bundle exec rake spec
&rdquo;`</p>

<h4 id="how-to-enable-overwriting">How to enable overwriting?</h4>

<p>To enable overwriting you have to <strong>enable it first</strong> (it&rsquo;s disabled by default for security reasons). 
You can do that by hand modifying runner configuration: <code class="prettyprint">config.toml</code>. 
Please go to section where is <code class="prettyprint">[runners.docker]</code> definition for your runner. 
Add <code class="prettyprint">allowed_images</code> and <code class="prettyprint">allowed_services</code> to specify what images are allowed to be picked from <code class="prettyprint">.gitlab-ci.yml</code>:
<code class="prettyprint">
[runners.docker]
  image = &quot;ruby:2.1&quot;
  allowed_images = [&quot;ruby:*&quot;, &quot;python:*&quot;]
  allowed_services = [&quot;mysql:*&quot;, &quot;redis:*&quot;]
</code>
This enables you to use in your <code class="prettyprint">.gitlab-ci.yml</code> any image that matches above wildcards. 
You will be able to pick only <code class="prettyprint">ruby</code> and <code class="prettyprint">python</code> images. 
The same rule can be applied to limit services. </p>

<p>If you are courageous enough, you can make it fully open and accept everything:
<code class="prettyprint">
[runners.docker]
  image = &quot;ruby:2.1&quot;
  allowed_images = [&quot;*&quot;, &quot;*/*&quot;]
  allowed_services = [&quot;*&quot;, &quot;*/*&quot;]
</code></p>

<p><strong>It the feature is not enabled, or image isn&rsquo;t allowed the error message will be put into the build log.</strong></p>

<h3 id="how-docker-integration-works">How Docker integration works</h3>

<ol>
<li>Create any service container: <code class="prettyprint">mysql</code>, <code class="prettyprint">postgresql</code>, <code class="prettyprint">mongodb</code>, <code class="prettyprint">redis</code>.</li>
<li>Create cache container to store all volumes as defined in <code class="prettyprint">config.toml</code> and <code class="prettyprint">Dockerfile</code> of build image (<code class="prettyprint">ruby:2.1</code> as in above example).</li>
<li>Create build container and link any service container to build container.</li>
<li>Start build container and send build script to the container.</li>
<li>Run build script.</li>
<li>Checkout code in: <code class="prettyprint">/builds/group-name/project-name/</code>.</li>
<li>Run any step defined in <code class="prettyprint">.gitlab-ci.yml</code>.</li>
<li>Check exit status of build script.</li>
<li>Remove build container and all created service containers.</li>
</ol>

<h3 id="how-to-debug-a-build-locally">How to debug a build locally</h3>

<ol>
<li><p>Create a file with build script:
<code class="prettyprint">bash
$ cat &lt;&lt;EOF &gt; build_script
git clone https://gitlab.com/gitlab-org/gitlab-ci-multi-runner.git /builds/gitlab-org/gitlab-ci-multi-runner
cd /builds/gitlab-org/gitlab-ci-multi-runner
make &lt;- or any other build step
EOF
</code></p></li>
<li><p>Create service containers:
<code class="prettyprint">
$ docker run -d -n service-mysql mysql:latest
$ docker run -d -n service-postgres postgres:latest
</code>
This will create two service containers (MySQL and PostgreSQL).</p></li>
<li><p>Create a build container and execute script in its context:
<code class="prettyprint">
$ cat build_script | docker run -n build -i -l mysql:service-mysql -l postgres:service-postgres ruby:2.1 /bin/bash
</code>
This will create build container that has two service containers linked.
The build_script is piped using STDIN to bash interpreter which executes the build script in container. </p></li>
<li><p>At the end remove all containers:
<code class="prettyprint">
docker rm -f -v build service-mysql service-postgres
</code>
This will forcefully (the <code class="prettyprint">-f</code> switch) remove build container and service containers 
and all volumes (the <code class="prettyprint">-v</code> switch) that were created with the container creation.</p></li>
</ol>
