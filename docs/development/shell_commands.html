<h1 id="guidelines-for-shell-commands-in-the-gitlab-codebase">Guidelines for shell commands in the GitLab codebase</h1>

<p>This document contains guidelines for working with processes and files in the GitLab codebase.
These guidelines are meant to make your code more reliable <em>and</em> secure.</p>

<h2 id="references">References</h2>

<ul>
<li><a href="https://code.google.com/p/ruby-security/wiki/Guide">Google Ruby Security Reviewer&rsquo;s Guide</a></li>
<li><a href="https://www.owasp.org/index.php/Command_Injection">OWASP Command Injection</a></li>
<li><a href="http://guides.rubyonrails.org/security.html#command-line-injection">Ruby on Rails Security Guide Command Line Injection</a></li>
</ul>

<h2 id="use-file-and-fileutils-instead-of-shell-commands">Use File and FileUtils instead of shell commands</h2>

<p>Sometimes we invoke basic Unix commands via the shell when there is also a Ruby API for doing it. Use the Ruby API if it exists. <a href="http://www.ruby-doc.org/stdlib-2.0.0/libdoc/fileutils/rdoc/FileUtils.html#module-FileUtils-label-Module+Functions">http://www.ruby-doc.org/stdlib-2.0.0/libdoc/fileutils/rdoc/FileUtils.html#module-FileUtils-label-Module+Functions</a></p>
<pre class="highlight ruby"><code><span class="c1"># Wrong</span>
<span class="nb">system</span> <span class="s2">"mkdir -p tmp/special/directory"</span>
<span class="c1"># Better (separate tokens)</span>
<span class="nb">system</span> <span class="o">*</span><span class="sx">%W(mkdir -p tmp/special/directory)</span>
<span class="c1"># Best (do not use a shell command)</span>
<span class="no">FileUtils</span><span class="p">.</span><span class="nf">mkdir_p</span> <span class="s2">"tmp/special/directory"</span>

<span class="c1"># Wrong</span>
<span class="n">contents</span> <span class="o">=</span> <span class="sb">`cat </span><span class="si">#{</span><span class="n">filename</span><span class="si">}</span><span class="sb">`</span>
<span class="c1"># Correct</span>
<span class="n">contents</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="c1"># Sometimes a shell command is just the best solution. The example below has no</span>
<span class="c1"># user input, and is hard to implement correctly in Ruby: delete all files and</span>
<span class="c1"># directories older than 120 minutes under /some/path, but not /some/path</span>
<span class="c1"># itself.</span>
<span class="no">Gitlab</span><span class="o">::</span><span class="no">Popen</span><span class="p">.</span><span class="nf">popen</span><span class="p">(</span><span class="sx">%W(find /some/path -not -path /some/path -mmin +120 -delete)</span><span class="p">)</span>
</code></pre>

<p>This coding style could have prevented CVE-2013-4490.</p>

<h2 id="bypass-the-shell-by-splitting-commands-into-separate-tokens">Bypass the shell by splitting commands into separate tokens</h2>

<p>When we pass shell commands as a single string to Ruby, Ruby will let <code class="prettyprint">/bin/sh</code> evaluate the entire string. Essentially, we are asking the shell to evaluate a one-line script. This creates a risk for shell injection attacks. It is better to split the shell command into tokens ourselves. Sometimes we use the scripting capabilities of the shell to change the working directory or set environment variables. All of this can also be achieved securely straight from Ruby</p>
<pre class="highlight ruby"><code><span class="c1"># Wrong</span>
<span class="nb">system</span> <span class="s2">"cd /home/git/gitlab &amp;&amp; bundle exec rake db:</span><span class="si">#{</span><span class="n">something</span><span class="si">}</span><span class="s2"> RAILS_ENV=production"</span>
<span class="c1"># Correct</span>
<span class="nb">system</span><span class="p">({</span><span class="s1">'RAILS_ENV'</span> <span class="o">=&gt;</span> <span class="s1">'production'</span><span class="p">},</span> <span class="o">*</span><span class="sx">%W(bundle exec rake db:</span><span class="si">#{</span><span class="n">something</span><span class="si">}</span><span class="sx">)</span><span class="p">,</span> <span class="ss">chdir: </span><span class="s1">'/home/git/gitlab'</span><span class="p">)</span>

<span class="c1"># Wrong</span>
<span class="nb">system</span> <span class="s2">"touch </span><span class="si">#{</span><span class="n">myfile</span><span class="si">}</span><span class="s2">"</span>
<span class="c1"># Better</span>
<span class="nb">system</span> <span class="s2">"touch"</span><span class="p">,</span> <span class="n">myfile</span>
<span class="c1"># Best (do not run a shell command at all)</span>
<span class="no">FileUtils</span><span class="p">.</span><span class="nf">touch</span> <span class="n">myfile</span>
</code></pre>

<p>This coding style could have prevented CVE-2013-4546.</p>

<h2 id="separate-options-from-arguments-with">Separate options from arguments with &ndash;</h2>

<p>Make the difference between options and arguments clear to the argument parsers of system commands with <code class="prettyprint">--</code>. This is supported by many but not all Unix commands.</p>

<p>To understand what <code class="prettyprint">--</code> does, consider the problem below.</p>
<pre class="highlight plaintext"><code># Example
$ echo hello &gt; -l
$ cat -l
cat: illegal option -- l
usage: cat [-benstuv] [file ...]
</code></pre>

<p>In the example above, the argument parser of <code class="prettyprint">cat</code> assumes that <code class="prettyprint">-l</code> is an option. The solution in the example above is to make it clear to <code class="prettyprint">cat</code> that <code class="prettyprint">-l</code> is really an argument, not an option. Many Unix command line tools follow the convention of separating options from arguments with <code class="prettyprint">--</code>.</p>
<pre class="highlight plaintext"><code># Example (continued)
$ cat -- -l
hello
</code></pre>

<p>In the GitLab codebase, we avoid the option/argument ambiguity by <em>always</em> using <code class="prettyprint">--</code>.</p>
<pre class="highlight ruby"><code><span class="c1"># Wrong</span>
<span class="nb">system</span><span class="p">(</span><span class="o">*</span><span class="sx">%W(git branch -d </span><span class="si">#{</span><span class="n">branch_name</span><span class="si">}</span><span class="sx">)</span><span class="p">)</span>
<span class="c1"># Correct</span>
<span class="nb">system</span><span class="p">(</span><span class="o">*</span><span class="sx">%W(git branch -d -- </span><span class="si">#{</span><span class="n">branch_name</span><span class="si">}</span><span class="sx">)</span><span class="p">)</span>
</code></pre>

<p>This coding style could have prevented CVE-2013-4582.</p>

<h2 id="do-not-use-the-backticks">Do not use the backticks</h2>

<p>Capturing the output of shell commands with backticks reads nicely, but you are forced to pass the command as one string to the shell. We explained above that this is unsafe. In the main GitLab codebase, the solution is to use <code class="prettyprint">Gitlab::Popen.popen</code> instead.</p>
<pre class="highlight ruby"><code><span class="c1"># Wrong</span>
<span class="n">logs</span> <span class="o">=</span> <span class="sb">`cd </span><span class="si">#{</span><span class="n">repo_dir</span><span class="si">}</span><span class="sb"> &amp;&amp; git log`</span>
<span class="c1"># Correct</span>
<span class="n">logs</span><span class="p">,</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="no">Gitlab</span><span class="o">::</span><span class="no">Popen</span><span class="p">.</span><span class="nf">popen</span><span class="p">(</span><span class="sx">%W(git log)</span><span class="p">,</span> <span class="n">repo_dir</span><span class="p">)</span>

<span class="c1"># Wrong</span>
<span class="n">user</span> <span class="o">=</span> <span class="sb">`whoami`</span>
<span class="c1"># Correct</span>
<span class="n">user</span><span class="p">,</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="no">Gitlab</span><span class="o">::</span><span class="no">Popen</span><span class="p">.</span><span class="nf">popen</span><span class="p">(</span><span class="sx">%W(whoami)</span><span class="p">)</span>
</code></pre>

<p>In other repositories, such as gitlab-shell you can also use <code class="prettyprint">IO.popen</code>.</p>
<pre class="highlight ruby"><code><span class="c1"># Safe IO.popen example</span>
<span class="n">logs</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">popen</span><span class="p">(</span><span class="sx">%W(git log)</span><span class="p">,</span> <span class="ss">chdir: </span><span class="n">repo_dir</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">read</span> <span class="p">}</span>
</code></pre>

<p>Note that unlike <code class="prettyprint">Gitlab::Popen.popen</code>, <code class="prettyprint">IO.popen</code> does not capture standard error.</p>

<h2 id="avoid-user-input-at-the-start-of-path-strings">Avoid user input at the start of path strings</h2>

<p>Various methods for opening and reading files in Ruby can be used to read the
standard output of a process instead of a file.  The following two commands do
roughly the same:</p>
<pre class="highlight plaintext"><code>`touch /tmp/pawned-by-backticks`
File.read('|touch /tmp/pawned-by-file-read')
</code></pre>

<p>The key is to open a &lsquo;file&rsquo; whose name starts with a <code class="prettyprint">|</code>.
Affected methods include Kernel#open, File::read, File::open, IO::open and IO::read.</p>

<p>You can protect against this behavior of &#39;open&rsquo; and &#39;read&rsquo; by ensuring that an
attacker cannot control the start of the filename string you are opening.  For
instance, the following is sufficient to protect against accidentally starting
a shell command with <code class="prettyprint">|</code>:</p>
<pre class="highlight plaintext"><code># we assume repo_path is not controlled by the attacker (user)
path = File.join(repo_path, user_input)
# path cannot start with '|' now.
File.read(path)
</code></pre>

<p>If you have to use user input a relative path, prefix <code class="prettyprint">./</code> to the path.</p>

<p>Prefixing user-supplied paths also offers extra protection against paths
starting with <code class="prettyprint">-</code> (see the discussion about using <code class="prettyprint">--</code> above).</p>

<h2 id="guard-against-path-traversal">Guard against path traversal</h2>

<p>Path traversal is a security where the program (GitLab) tries to restrict user
access to a certain directory on disk, but the user manages to open a file
outside that directory by taking advantage of the <code class="prettyprint">../</code> path notation.</p>
<pre class="highlight plaintext"><code># Suppose the user gave us a path and they are trying to trick us
user_input = '../other-repo.git/other-file'

# We look up the repo path somewhere
repo_path = 'repositories/user-repo.git'

# The intention of the code below is to open a file under repo_path, but
# because the user used '..' she can 'break out' into
# 'repositories/other-repo.git'
full_path = File.join(repo_path, user_input)
File.open(full_path) do # Oops!
</code></pre>

<p>A good way to protect against this is to compare the full path with its
&#39;absolute path&rsquo; according to Ruby&rsquo;s <code class="prettyprint">File.absolute_path</code>.</p>
<pre class="highlight plaintext"><code>full_path = File.join(repo_path, user_input)
if full_path != File.absolute_path(full_path)
  raise "Invalid path: #{full_path.inspect}"
end

File.open(full_path) do # Etc.
</code></pre>

<p>A check like this could have avoided CVE-2013-4583.</p>

<h2 id="properly-anchor-regular-expressions-to-the-start-and-end-of-strings">Properly anchor regular expressions to the start and end of strings</h2>

<p>When using regular expressions to validate user input that is passed as an argument to a shell command, make sure to use the <code class="prettyprint">\A</code> and <code class="prettyprint">\z</code> anchors that designate the start and end of the string, rather than <code class="prettyprint">^</code> and <code class="prettyprint">$</code>, or no anchors at all. </p>

<p>If you don&rsquo;t, an attacker could use this to execute commands with potentially harmful effect.</p>

<p>For example, when a project&rsquo;s <code class="prettyprint">import_url</code> is validated like below, the user could trick GitLab into cloning from a Git repository on the local filesystem.</p>
<pre class="highlight ruby"><code><span class="n">validates</span> <span class="ss">:import_url</span><span class="p">,</span> <span class="ss">format: </span><span class="p">{</span> <span class="ss">with: </span><span class="no">URI</span><span class="p">.</span><span class="nf">regexp</span><span class="p">(</span><span class="sx">%w(ssh git http https)</span><span class="p">)</span> <span class="p">}</span>
<span class="c1"># URI.regexp(%w(ssh git http https)) roughly evaluates to /(ssh|git|http|https):(something_that_looks_like_a_url)/ </span>
</code></pre>

<p>Suppose the user submits the following as their import URL:</p>
<pre class="highlight plaintext"><code>file://git:/tmp/lol
</code></pre>

<p>Since there are no anchors in the used regular expression, the <code class="prettyprint">git:/tmp/lol</code> in the value would match, and the validation would pass.</p>

<p>When importing, GitLab would execute the following command, passing the <code class="prettyprint">import_url</code> as an argument:</p>
<pre class="highlight shell"><code>git clone file://git:/tmp/lol
</code></pre>

<p>Git would simply ignore the <code class="prettyprint">git:</code> part, interpret the path as <code class="prettyprint">file:///tmp/lol</code> and import the repository into the new project, in turn potentially giving the attacker access to any repository in the system, whether private or not.</p>
